import { _isType, curry, curry4, intercalate, isArray, isFunction, isString, isset, length, map, typeOf } from 'fjl';

/**
 * @memberOf module:fjlErrorThrowing
 * @property {String} version - Semantic version string.
 * @note Content generated by '{project-root}/node-scripts/VersionNumberReadStream.js'.
 * @generated Mon Jun 04 2018 18:51:11 GMT-0400 (Eastern Daylight Time) 
 */

let version = '0.7.8';

/**
 * @module fjlErrorThrowing
 * @description Contains error throwing facilities for when a value doesn't match a type.
 *  In addition gives you curried and uncurried versions of the multi arity functions included.
 */
const isCheckableType = type => isString(type) || isFunction(type);
const errorIfNotCheckableType = (contextName, type) => {
        if (!isCheckableType(type)) {
            throw new Error (`${contextName} expects \`type\` to be of type \`String\` or \`Function\`.` +
                `  Type received \`${typeOf(type)}\`.  Value \`${type}\`.`);
        }
        return type;
    };
const getTypeName = type =>
        errorIfNotCheckableType('getTypeName', type) &&
            isString(type) ? type : type.name;
const defaultTypeChecker$ = (Type, value) => _isType(getTypeName(Type), value) || (
        isFunction(Type) && isset(value) && value instanceof Type);
const multiTypesToString = types => length(types) ?
             intercalate(', ', map(type => `\`${getTypeName(type)}\``, types)) : '';
const defaultErrorMessageCall = tmplContext => {
        const {
            contextName, valueName, value, expectedTypeName,
            foundTypeName, messageSuffix
        } = tmplContext,
            isMultiTypeNames = isArray(expectedTypeName),
            typesCopy = isMultiTypeNames ? 'of type' : 'of one of the types',
            typesToMatchCopy = isMultiTypeNames ? multiTypesToString(expectedTypeName) : expectedTypeName;
        return (contextName ? `\`${contextName}.` : '`') +
            `${valueName}\` is not ${typesCopy}: ${typesToMatchCopy}.  ` +
            `Type received: ${foundTypeName}.  Value: ${value};` +
            `${messageSuffix ?  '  ' + messageSuffix + ';' : ''}`;
    };
const getErrorIfNotTypeThrower$ = (errorMessageCall, typeChecker = defaultTypeChecker$) =>
      (ValueType, contextName, valueName, value, messageSuffix = null) => {
        const expectedTypeName = getTypeName(ValueType),
            foundTypeName = typeOf(value);
        if (typeChecker(ValueType, value)) { return; } // Value matches type
        throw new Error(errorMessageCall(
            {contextName, valueName, value, expectedTypeName, foundTypeName, messageSuffix}
        ));
    };
const getErrorIfNotTypesThrower$ = (errorMessageCall, typeChecker = defaultTypeChecker$) =>
      (valueTypes, contextName, valueName, value) => {
            const expectedTypeNames = valueTypes.map(getTypeName),
                matchFound = valueTypes.some(ValueType => typeChecker(ValueType, value)),
                foundTypeName = typeOf(value);
            if (matchFound) { return; }
            throw new Error(
                errorMessageCall({
                    contextName, valueName, value,
                    expectedTypeName: expectedTypeNames, foundTypeName
                })
            );
        };
const errorIfNotType$ = getErrorIfNotTypeThrower$(defaultErrorMessageCall);
const errorIfNotTypes$ = getErrorIfNotTypesThrower$(defaultErrorMessageCall);
const defaultTypeChecker = curry(defaultTypeChecker$);
const errorIfNotType = curry(errorIfNotType$);
const errorIfNotTypes = curry4(errorIfNotTypes$);
const getErrorIfNotTypeThrower = errorMessageCall => curry(getErrorIfNotTypeThrower$(errorMessageCall));
const getErrorIfNotTypesThrower = errorMessageCall => curry4(getErrorIfNotTypesThrower$(errorMessageCall));

var fjl_errorThrowing = {
    defaultTypeChecker$,
    defaultTypeChecker,
    getTypeName,
    multiTypesToString,
    defaultErrorMessageCall,
    errorIfNotType$,
    errorIfNotType,
    errorIfNotTypes$,
    errorIfNotTypes,
    getErrorIfNotTypeThrower$,
    getErrorIfNotTypeThrower,
    getErrorIfNotTypesThrower$,
    getErrorIfNotTypesThrower
};

export { isCheckableType, errorIfNotCheckableType, getTypeName, defaultTypeChecker$, multiTypesToString, defaultErrorMessageCall, getErrorIfNotTypeThrower$, getErrorIfNotTypesThrower$, errorIfNotType$, errorIfNotTypes$, defaultTypeChecker, errorIfNotType, errorIfNotTypes, getErrorIfNotTypeThrower, getErrorIfNotTypesThrower, version };export default fjl_errorThrowing;
