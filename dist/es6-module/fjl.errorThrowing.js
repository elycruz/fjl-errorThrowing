import { _isType, intercalate, isArray, isFunction, isString, length, map, typeOf } from 'fjl';

/**
 * Content generated by '{project-root}/node-scripts/VersionNumberReadStream.js'.
 * Generated Sun Oct 15 2017 23:15:15 GMT-0400 (Eastern Daylight Time) 
 */

let version = '1.0.0';

/**
 * @module fjlErrorThrowing
 * Exports `errorIfNotType` factories and the utilities to create such.
 */
/**
 * @name errorMessageCall
 * @function
 * @param context {Object|TemplateContext}
 * @returns {String}
 */

/** ------------------------------------------------------------------
 * Custom types (returned function and/or objects).
 * @typedef {*} Any
 * @typedef {Object<contextName, valueName, value, expectedTypeName, foundTypeName, messageSuffix>} TemplateContext
 * @typedef {Function} errorMessageCall
 * @typedef {Array} TypesArray
 * @typedef {Function} errorIfNotType
 * @typedef {Function} errorIfNotTypes
 * ------------------------------------------------------------------ */

const getTypeName = type => {
        if (isString(type)) { return type; }
        else if (isFunction(type)) { return type.name; }
        throw Error('`fjl.error.getTypeName` only accepts strings and/or constructors.  ' +
            'Value type received: ' + typeOf(type) + ';  Value: ' + type);
    };
const multiTypesToString = types => length(types) ?
             intercalate(', ', map(type => `\`${getTypeName(type)}\``, types)) : '';
const defaultErrorMessageCall = tmplContext => {
        const {
            contextName, valueName, value, expectedTypeName,
            foundTypeName, messageSuffix
        } = tmplContext,
            isMultiTypeNames = isArray(expectedTypeName),
            typesCopy = isMultiTypeNames ? 'of type' : 'of one of the types',
            typesToMatchCopy = isMultiTypeNames ? multiTypesToString(expectedTypeName) : expectedTypeName;
        return (contextName ? `\`${contextName}.` : '`') +
            `${valueName}\` is not ${typesCopy}: ${typesToMatchCopy}.  ` +
            `Type received: ${foundTypeName}.  Value: ${value};` +
            `${messageSuffix ?  '  ' + messageSuffix + ';' : ''}`;
    };
const getErrorIfNotTypeThrower = (contextName, errorMessageCall) => (valueName, value, ValueType, messageSuffix = null) => {
        const expectedTypeName = getTypeName(ValueType),
            foundTypeName = typeOf(value);
        if (_isType(expectedTypeName, value)) { return; }
        throw new Error(errorMessageCall(
            {contextName, valueName, value, expectedTypeName, foundTypeName, messageSuffix}
        ));
    };
const getErrorIfNotTypesThrower = (contextName, errorMessageCall) => (valueName, value, ...valueTypes) => {
        const expectedTypeNames = valueTypes.map(getTypeName),
            matchFound = expectedTypeNames.some(ValueType => _isType(ValueType, value)),
            foundTypeName = typeOf(value);
        if (matchFound) { return; }
        throw new Error(
            errorMessageCall({
                contextName, valueName, value,
                expectedTypeName: expectedTypeNames, foundTypeName
            })
        );
    };
const errorIfNotTypeThrower = contextName =>
        getErrorIfNotTypeThrower(contextName, defaultErrorMessageCall);
const errorIfNotTypesThrower = contextName =>
        getErrorIfNotTypesThrower(contextName, defaultErrorMessageCall);

export { getTypeName, multiTypesToString, defaultErrorMessageCall, getErrorIfNotTypeThrower, getErrorIfNotTypesThrower, errorIfNotTypeThrower, errorIfNotTypesThrower, version };
